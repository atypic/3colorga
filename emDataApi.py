#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  """
  For efficiency, wave data is stored in a central repository. This means programs do not have to transfer the whole dataset around when working in a distributed fashion.

  Wavebuffers are stored in a hashtable, as a {string,emWaveForm} pair.

  Client applications need to tidy up the hashtable by deleting waveforms that are no longer used.

  """
  def createBuffer(self, length):
    """
    Make a buffer of a certain length, returns its name

    Parameters:
     - length: The length
    """
    pass

  def destroyBuffer(self, bufferName):
    """
    Frees the named buffer

    Parameters:
     - bufferName: The name of the buffer
    """
    pass

  def getBuffer(self, bufferName):
    """
    Get the actual raw data

    Parameters:
     - bufferName: The name of the buffer
    """
    pass

  def setBuffer(self, samples):
    """
    Creates a buffer from an existing sample

    Parameters:
     - samples: Existing source
    """
    pass

  def cloneBuffer(self, bufferName):
    """
    Copies a buffer, returns the copies name

    Parameters:
     - bufferName
    """
    pass

  def renameBuffer(self, oldBufferName, newBufferName):
    """
    Rename a buffer, can be used to make code human readable

    Parameters:
     - oldBufferName: The buffer to rename
     - newBufferName: The new name
    """
    pass

  def saveBuffer(self, bufferName, fileName):
    """
    Rename a buffer

    Parameters:
     - bufferName: The buffer name
     - fileName: Where to save it to
    """
    pass

  def loadBuffer(self, fileName):
    """
    Load a buffer from disc. Returns the name of the new buffer

    Parameters:
     - fileName: File containing the buffer
    """
    pass

  def absDifference(self, bufferA, bufferB):
    """
    Element wise, compute difference of two buffers. Returns name of the output buffer.

    Parameters:
     - bufferA
     - bufferB
    """
    pass

  def sum(self, bufferName):
    """
    Find the sum of the buffer

    Parameters:
     - bufferName
    """
    pass

  def sumSquaredDifference(self, bufferA, bufferB):
    """
    Computes the sum squared difference of two buffers

    Parameters:
     - bufferA
     - bufferB
    """
    pass

  def subtract(self, bufferA, bufferB):
    """
    Element wise subtraction, e.g. bufferA[n] - bufferB[n]. Returns name of the output buffer.

    Parameters:
     - bufferA
     - bufferB
    """
    pass

  def add(self, bufferA, bufferB):
    """
    Element wise addition, e.g. bufferA[n] +  bufferB[n]. Returns name of the output buffer.

    Parameters:
     - bufferA
     - bufferB
    """
    pass

  def setValues(self, bufferName, value):
    """
    Set all the values in the buffer to value

    Parameters:
     - bufferName: Buffer name
     - value: New value
    """
    pass

  def threshold(self, bufferName, thresholdValue, maxValue, invert):
    """
    if value<threshold, 0 else maxValue. invert does the opposite. Returns name of new buffer

    Parameters:
     - bufferName: Buffer name
     - thresholdValue: Value to test against
     - maxValue: Value to set if condition is met
     - invert: Invert response
    """
    pass

  def normalize(self, bufferName, minValue, maxValue):
    """
    Normalize the data. Returns name of new buffer

    Parameters:
     - bufferName: Buffer name
     - minValue: Normalize from
     - maxValue: Normalize to
    """
    pass

  def quantize(self, bufferName, minValue, maxValue, levels):
    """
    Quantize the data to discrete levels. Returns name of new buffer

    Parameters:
     - bufferName: Buffer name
     - minValue: Normalize from
     - maxValue: Normalize to
     - levels: How many discrete levels to quantize to
    """
    pass

  def resample(self, bufferName, newLength):
    """
    Resize the data buffer. Returns name of new buffer.

    Parameters:
     - bufferName: Buffer name
     - newLength: Number of samples in returned buffer
    """
    pass

  def medianFilter(self, bufferName, fitlerSize):
    """
    Applies the median filter for noise supression.  Returns name of new buffer.

    Parameters:
     - bufferName: Buffer name
     - fitlerSize: Strength of the filter. Larger number is stronger. Must be >=1
    """
    pass


class Client(Iface):
  """
  For efficiency, wave data is stored in a central repository. This means programs do not have to transfer the whole dataset around when working in a distributed fashion.

  Wavebuffers are stored in a hashtable, as a {string,emWaveForm} pair.

  Client applications need to tidy up the hashtable by deleting waveforms that are no longer used.

  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def createBuffer(self, length):
    """
    Make a buffer of a certain length, returns its name

    Parameters:
     - length: The length
    """
    self.send_createBuffer(length)
    return self.recv_createBuffer()

  def send_createBuffer(self, length):
    self._oprot.writeMessageBegin('createBuffer', TMessageType.CALL, self._seqid)
    args = createBuffer_args()
    args.length = length
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createBuffer(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createBuffer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createBuffer failed: unknown result");

  def destroyBuffer(self, bufferName):
    """
    Frees the named buffer

    Parameters:
     - bufferName: The name of the buffer
    """
    self.send_destroyBuffer(bufferName)
    self.recv_destroyBuffer()

  def send_destroyBuffer(self, bufferName):
    self._oprot.writeMessageBegin('destroyBuffer', TMessageType.CALL, self._seqid)
    args = destroyBuffer_args()
    args.bufferName = bufferName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_destroyBuffer(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = destroyBuffer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.err is not None:
      raise result.err
    return

  def getBuffer(self, bufferName):
    """
    Get the actual raw data

    Parameters:
     - bufferName: The name of the buffer
    """
    self.send_getBuffer(bufferName)
    return self.recv_getBuffer()

  def send_getBuffer(self, bufferName):
    self._oprot.writeMessageBegin('getBuffer', TMessageType.CALL, self._seqid)
    args = getBuffer_args()
    args.bufferName = bufferName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getBuffer(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getBuffer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getBuffer failed: unknown result");

  def setBuffer(self, samples):
    """
    Creates a buffer from an existing sample

    Parameters:
     - samples: Existing source
    """
    self.send_setBuffer(samples)
    return self.recv_setBuffer()

  def send_setBuffer(self, samples):
    self._oprot.writeMessageBegin('setBuffer', TMessageType.CALL, self._seqid)
    args = setBuffer_args()
    args.samples = samples
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setBuffer(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setBuffer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setBuffer failed: unknown result");

  def cloneBuffer(self, bufferName):
    """
    Copies a buffer, returns the copies name

    Parameters:
     - bufferName
    """
    self.send_cloneBuffer(bufferName)
    return self.recv_cloneBuffer()

  def send_cloneBuffer(self, bufferName):
    self._oprot.writeMessageBegin('cloneBuffer', TMessageType.CALL, self._seqid)
    args = cloneBuffer_args()
    args.bufferName = bufferName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cloneBuffer(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cloneBuffer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cloneBuffer failed: unknown result");

  def renameBuffer(self, oldBufferName, newBufferName):
    """
    Rename a buffer, can be used to make code human readable

    Parameters:
     - oldBufferName: The buffer to rename
     - newBufferName: The new name
    """
    self.send_renameBuffer(oldBufferName, newBufferName)
    self.recv_renameBuffer()

  def send_renameBuffer(self, oldBufferName, newBufferName):
    self._oprot.writeMessageBegin('renameBuffer', TMessageType.CALL, self._seqid)
    args = renameBuffer_args()
    args.oldBufferName = oldBufferName
    args.newBufferName = newBufferName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_renameBuffer(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = renameBuffer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.err is not None:
      raise result.err
    return

  def saveBuffer(self, bufferName, fileName):
    """
    Rename a buffer

    Parameters:
     - bufferName: The buffer name
     - fileName: Where to save it to
    """
    self.send_saveBuffer(bufferName, fileName)
    self.recv_saveBuffer()

  def send_saveBuffer(self, bufferName, fileName):
    self._oprot.writeMessageBegin('saveBuffer', TMessageType.CALL, self._seqid)
    args = saveBuffer_args()
    args.bufferName = bufferName
    args.fileName = fileName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_saveBuffer(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = saveBuffer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.err is not None:
      raise result.err
    return

  def loadBuffer(self, fileName):
    """
    Load a buffer from disc. Returns the name of the new buffer

    Parameters:
     - fileName: File containing the buffer
    """
    self.send_loadBuffer(fileName)
    return self.recv_loadBuffer()

  def send_loadBuffer(self, fileName):
    self._oprot.writeMessageBegin('loadBuffer', TMessageType.CALL, self._seqid)
    args = loadBuffer_args()
    args.fileName = fileName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_loadBuffer(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = loadBuffer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "loadBuffer failed: unknown result");

  def absDifference(self, bufferA, bufferB):
    """
    Element wise, compute difference of two buffers. Returns name of the output buffer.

    Parameters:
     - bufferA
     - bufferB
    """
    self.send_absDifference(bufferA, bufferB)
    return self.recv_absDifference()

  def send_absDifference(self, bufferA, bufferB):
    self._oprot.writeMessageBegin('absDifference', TMessageType.CALL, self._seqid)
    args = absDifference_args()
    args.bufferA = bufferA
    args.bufferB = bufferB
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_absDifference(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = absDifference_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "absDifference failed: unknown result");

  def sum(self, bufferName):
    """
    Find the sum of the buffer

    Parameters:
     - bufferName
    """
    self.send_sum(bufferName)
    return self.recv_sum()

  def send_sum(self, bufferName):
    self._oprot.writeMessageBegin('sum', TMessageType.CALL, self._seqid)
    args = sum_args()
    args.bufferName = bufferName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sum(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sum_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sum failed: unknown result");

  def sumSquaredDifference(self, bufferA, bufferB):
    """
    Computes the sum squared difference of two buffers

    Parameters:
     - bufferA
     - bufferB
    """
    self.send_sumSquaredDifference(bufferA, bufferB)
    return self.recv_sumSquaredDifference()

  def send_sumSquaredDifference(self, bufferA, bufferB):
    self._oprot.writeMessageBegin('sumSquaredDifference', TMessageType.CALL, self._seqid)
    args = sumSquaredDifference_args()
    args.bufferA = bufferA
    args.bufferB = bufferB
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumSquaredDifference(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sumSquaredDifference_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumSquaredDifference failed: unknown result");

  def subtract(self, bufferA, bufferB):
    """
    Element wise subtraction, e.g. bufferA[n] - bufferB[n]. Returns name of the output buffer.

    Parameters:
     - bufferA
     - bufferB
    """
    self.send_subtract(bufferA, bufferB)
    return self.recv_subtract()

  def send_subtract(self, bufferA, bufferB):
    self._oprot.writeMessageBegin('subtract', TMessageType.CALL, self._seqid)
    args = subtract_args()
    args.bufferA = bufferA
    args.bufferB = bufferB
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_subtract(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = subtract_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "subtract failed: unknown result");

  def add(self, bufferA, bufferB):
    """
    Element wise addition, e.g. bufferA[n] +  bufferB[n]. Returns name of the output buffer.

    Parameters:
     - bufferA
     - bufferB
    """
    self.send_add(bufferA, bufferB)
    return self.recv_add()

  def send_add(self, bufferA, bufferB):
    self._oprot.writeMessageBegin('add', TMessageType.CALL, self._seqid)
    args = add_args()
    args.bufferA = bufferA
    args.bufferB = bufferB
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add failed: unknown result");

  def setValues(self, bufferName, value):
    """
    Set all the values in the buffer to value

    Parameters:
     - bufferName: Buffer name
     - value: New value
    """
    self.send_setValues(bufferName, value)
    self.recv_setValues()

  def send_setValues(self, bufferName, value):
    self._oprot.writeMessageBegin('setValues', TMessageType.CALL, self._seqid)
    args = setValues_args()
    args.bufferName = bufferName
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setValues(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setValues_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.err is not None:
      raise result.err
    return

  def threshold(self, bufferName, thresholdValue, maxValue, invert):
    """
    if value<threshold, 0 else maxValue. invert does the opposite. Returns name of new buffer

    Parameters:
     - bufferName: Buffer name
     - thresholdValue: Value to test against
     - maxValue: Value to set if condition is met
     - invert: Invert response
    """
    self.send_threshold(bufferName, thresholdValue, maxValue, invert)
    return self.recv_threshold()

  def send_threshold(self, bufferName, thresholdValue, maxValue, invert):
    self._oprot.writeMessageBegin('threshold', TMessageType.CALL, self._seqid)
    args = threshold_args()
    args.bufferName = bufferName
    args.thresholdValue = thresholdValue
    args.maxValue = maxValue
    args.invert = invert
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_threshold(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = threshold_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "threshold failed: unknown result");

  def normalize(self, bufferName, minValue, maxValue):
    """
    Normalize the data. Returns name of new buffer

    Parameters:
     - bufferName: Buffer name
     - minValue: Normalize from
     - maxValue: Normalize to
    """
    self.send_normalize(bufferName, minValue, maxValue)
    return self.recv_normalize()

  def send_normalize(self, bufferName, minValue, maxValue):
    self._oprot.writeMessageBegin('normalize', TMessageType.CALL, self._seqid)
    args = normalize_args()
    args.bufferName = bufferName
    args.minValue = minValue
    args.maxValue = maxValue
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_normalize(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = normalize_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "normalize failed: unknown result");

  def quantize(self, bufferName, minValue, maxValue, levels):
    """
    Quantize the data to discrete levels. Returns name of new buffer

    Parameters:
     - bufferName: Buffer name
     - minValue: Normalize from
     - maxValue: Normalize to
     - levels: How many discrete levels to quantize to
    """
    self.send_quantize(bufferName, minValue, maxValue, levels)
    return self.recv_quantize()

  def send_quantize(self, bufferName, minValue, maxValue, levels):
    self._oprot.writeMessageBegin('quantize', TMessageType.CALL, self._seqid)
    args = quantize_args()
    args.bufferName = bufferName
    args.minValue = minValue
    args.maxValue = maxValue
    args.levels = levels
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_quantize(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = quantize_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "quantize failed: unknown result");

  def resample(self, bufferName, newLength):
    """
    Resize the data buffer. Returns name of new buffer.

    Parameters:
     - bufferName: Buffer name
     - newLength: Number of samples in returned buffer
    """
    self.send_resample(bufferName, newLength)
    return self.recv_resample()

  def send_resample(self, bufferName, newLength):
    self._oprot.writeMessageBegin('resample', TMessageType.CALL, self._seqid)
    args = resample_args()
    args.bufferName = bufferName
    args.newLength = newLength
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_resample(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = resample_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "resample failed: unknown result");

  def medianFilter(self, bufferName, fitlerSize):
    """
    Applies the median filter for noise supression.  Returns name of new buffer.

    Parameters:
     - bufferName: Buffer name
     - fitlerSize: Strength of the filter. Larger number is stronger. Must be >=1
    """
    self.send_medianFilter(bufferName, fitlerSize)
    return self.recv_medianFilter()

  def send_medianFilter(self, bufferName, fitlerSize):
    self._oprot.writeMessageBegin('medianFilter', TMessageType.CALL, self._seqid)
    args = medianFilter_args()
    args.bufferName = bufferName
    args.fitlerSize = fitlerSize
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_medianFilter(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = medianFilter_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    raise TApplicationException(TApplicationException.MISSING_RESULT, "medianFilter failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["createBuffer"] = Processor.process_createBuffer
    self._processMap["destroyBuffer"] = Processor.process_destroyBuffer
    self._processMap["getBuffer"] = Processor.process_getBuffer
    self._processMap["setBuffer"] = Processor.process_setBuffer
    self._processMap["cloneBuffer"] = Processor.process_cloneBuffer
    self._processMap["renameBuffer"] = Processor.process_renameBuffer
    self._processMap["saveBuffer"] = Processor.process_saveBuffer
    self._processMap["loadBuffer"] = Processor.process_loadBuffer
    self._processMap["absDifference"] = Processor.process_absDifference
    self._processMap["sum"] = Processor.process_sum
    self._processMap["sumSquaredDifference"] = Processor.process_sumSquaredDifference
    self._processMap["subtract"] = Processor.process_subtract
    self._processMap["add"] = Processor.process_add
    self._processMap["setValues"] = Processor.process_setValues
    self._processMap["threshold"] = Processor.process_threshold
    self._processMap["normalize"] = Processor.process_normalize
    self._processMap["quantize"] = Processor.process_quantize
    self._processMap["resample"] = Processor.process_resample
    self._processMap["medianFilter"] = Processor.process_medianFilter

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_createBuffer(self, seqid, iprot, oprot):
    args = createBuffer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createBuffer_result()
    try:
      result.success = self._handler.createBuffer(args.length)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("createBuffer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_destroyBuffer(self, seqid, iprot, oprot):
    args = destroyBuffer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = destroyBuffer_result()
    try:
      self._handler.destroyBuffer(args.bufferName)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("destroyBuffer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getBuffer(self, seqid, iprot, oprot):
    args = getBuffer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getBuffer_result()
    try:
      result.success = self._handler.getBuffer(args.bufferName)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("getBuffer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setBuffer(self, seqid, iprot, oprot):
    args = setBuffer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setBuffer_result()
    try:
      result.success = self._handler.setBuffer(args.samples)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("setBuffer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cloneBuffer(self, seqid, iprot, oprot):
    args = cloneBuffer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cloneBuffer_result()
    try:
      result.success = self._handler.cloneBuffer(args.bufferName)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("cloneBuffer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_renameBuffer(self, seqid, iprot, oprot):
    args = renameBuffer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = renameBuffer_result()
    try:
      self._handler.renameBuffer(args.oldBufferName, args.newBufferName)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("renameBuffer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_saveBuffer(self, seqid, iprot, oprot):
    args = saveBuffer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = saveBuffer_result()
    try:
      self._handler.saveBuffer(args.bufferName, args.fileName)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("saveBuffer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_loadBuffer(self, seqid, iprot, oprot):
    args = loadBuffer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = loadBuffer_result()
    try:
      result.success = self._handler.loadBuffer(args.fileName)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("loadBuffer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_absDifference(self, seqid, iprot, oprot):
    args = absDifference_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = absDifference_result()
    try:
      result.success = self._handler.absDifference(args.bufferA, args.bufferB)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("absDifference", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sum(self, seqid, iprot, oprot):
    args = sum_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sum_result()
    try:
      result.success = self._handler.sum(args.bufferName)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("sum", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumSquaredDifference(self, seqid, iprot, oprot):
    args = sumSquaredDifference_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumSquaredDifference_result()
    try:
      result.success = self._handler.sumSquaredDifference(args.bufferA, args.bufferB)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("sumSquaredDifference", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_subtract(self, seqid, iprot, oprot):
    args = subtract_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = subtract_result()
    try:
      result.success = self._handler.subtract(args.bufferA, args.bufferB)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("subtract", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add(self, seqid, iprot, oprot):
    args = add_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_result()
    try:
      result.success = self._handler.add(args.bufferA, args.bufferB)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("add", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setValues(self, seqid, iprot, oprot):
    args = setValues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setValues_result()
    try:
      self._handler.setValues(args.bufferName, args.value)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("setValues", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_threshold(self, seqid, iprot, oprot):
    args = threshold_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = threshold_result()
    try:
      result.success = self._handler.threshold(args.bufferName, args.thresholdValue, args.maxValue, args.invert)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("threshold", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_normalize(self, seqid, iprot, oprot):
    args = normalize_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = normalize_result()
    try:
      result.success = self._handler.normalize(args.bufferName, args.minValue, args.maxValue)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("normalize", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_quantize(self, seqid, iprot, oprot):
    args = quantize_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = quantize_result()
    try:
      result.success = self._handler.quantize(args.bufferName, args.minValue, args.maxValue, args.levels)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("quantize", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_resample(self, seqid, iprot, oprot):
    args = resample_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = resample_result()
    try:
      result.success = self._handler.resample(args.bufferName, args.newLength)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("resample", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_medianFilter(self, seqid, iprot, oprot):
    args = medianFilter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = medianFilter_result()
    try:
      result.success = self._handler.medianFilter(args.bufferName, args.fitlerSize)
    except emException, err:
      result.err = err
    oprot.writeMessageBegin("medianFilter", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class createBuffer_args:
  """
  Attributes:
   - length: The length
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'length', None, None, ), # 1
  )

  def __init__(self, length=None,):
    self.length = length

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.length = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createBuffer_args')
    if self.length is not None:
      oprot.writeFieldBegin('length', TType.I64, 1)
      oprot.writeI64(self.length)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createBuffer_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createBuffer_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class destroyBuffer_args:
  """
  Attributes:
   - bufferName: The name of the buffer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferName', None, None, ), # 1
  )

  def __init__(self, bufferName=None,):
    self.bufferName = bufferName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('destroyBuffer_args')
    if self.bufferName is not None:
      oprot.writeFieldBegin('bufferName', TType.STRING, 1)
      oprot.writeString(self.bufferName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class destroyBuffer_result:
  """
  Attributes:
   - err
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, err=None,):
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('destroyBuffer_result')
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBuffer_args:
  """
  Attributes:
   - bufferName: The name of the buffer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferName', None, None, ), # 1
  )

  def __init__(self, bufferName=None,):
    self.bufferName = bufferName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBuffer_args')
    if self.bufferName is not None:
      oprot.writeFieldBegin('bufferName', TType.STRING, 1)
      oprot.writeString(self.bufferName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBuffer_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (emWaveForm, emWaveForm.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = emWaveForm()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBuffer_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setBuffer_args:
  """
  Attributes:
   - samples: Existing source
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'samples', (emWaveForm, emWaveForm.thrift_spec), None, ), # 1
  )

  def __init__(self, samples=None,):
    self.samples = samples

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.samples = emWaveForm()
          self.samples.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setBuffer_args')
    if self.samples is not None:
      oprot.writeFieldBegin('samples', TType.STRUCT, 1)
      self.samples.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setBuffer_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setBuffer_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cloneBuffer_args:
  """
  Attributes:
   - bufferName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferName', None, None, ), # 1
  )

  def __init__(self, bufferName=None,):
    self.bufferName = bufferName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cloneBuffer_args')
    if self.bufferName is not None:
      oprot.writeFieldBegin('bufferName', TType.STRING, 1)
      oprot.writeString(self.bufferName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cloneBuffer_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cloneBuffer_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renameBuffer_args:
  """
  Attributes:
   - oldBufferName: The buffer to rename
   - newBufferName: The new name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'oldBufferName', None, None, ), # 1
    (2, TType.STRING, 'newBufferName', None, None, ), # 2
  )

  def __init__(self, oldBufferName=None, newBufferName=None,):
    self.oldBufferName = oldBufferName
    self.newBufferName = newBufferName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.oldBufferName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.newBufferName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renameBuffer_args')
    if self.oldBufferName is not None:
      oprot.writeFieldBegin('oldBufferName', TType.STRING, 1)
      oprot.writeString(self.oldBufferName)
      oprot.writeFieldEnd()
    if self.newBufferName is not None:
      oprot.writeFieldBegin('newBufferName', TType.STRING, 2)
      oprot.writeString(self.newBufferName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renameBuffer_result:
  """
  Attributes:
   - err
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, err=None,):
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renameBuffer_result')
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class saveBuffer_args:
  """
  Attributes:
   - bufferName: The buffer name
   - fileName: Where to save it to
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferName', None, None, ), # 1
    (2, TType.STRING, 'fileName', None, None, ), # 2
  )

  def __init__(self, bufferName=None, fileName=None,):
    self.bufferName = bufferName
    self.fileName = fileName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fileName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('saveBuffer_args')
    if self.bufferName is not None:
      oprot.writeFieldBegin('bufferName', TType.STRING, 1)
      oprot.writeString(self.bufferName)
      oprot.writeFieldEnd()
    if self.fileName is not None:
      oprot.writeFieldBegin('fileName', TType.STRING, 2)
      oprot.writeString(self.fileName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class saveBuffer_result:
  """
  Attributes:
   - err
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, err=None,):
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('saveBuffer_result')
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class loadBuffer_args:
  """
  Attributes:
   - fileName: File containing the buffer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'fileName', None, None, ), # 1
  )

  def __init__(self, fileName=None,):
    self.fileName = fileName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.fileName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('loadBuffer_args')
    if self.fileName is not None:
      oprot.writeFieldBegin('fileName', TType.STRING, 1)
      oprot.writeString(self.fileName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class loadBuffer_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('loadBuffer_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class absDifference_args:
  """
  Attributes:
   - bufferA
   - bufferB
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferA', None, None, ), # 1
    (2, TType.STRING, 'bufferB', None, None, ), # 2
  )

  def __init__(self, bufferA=None, bufferB=None,):
    self.bufferA = bufferA
    self.bufferB = bufferB

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferA = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.bufferB = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('absDifference_args')
    if self.bufferA is not None:
      oprot.writeFieldBegin('bufferA', TType.STRING, 1)
      oprot.writeString(self.bufferA)
      oprot.writeFieldEnd()
    if self.bufferB is not None:
      oprot.writeFieldBegin('bufferB', TType.STRING, 2)
      oprot.writeString(self.bufferB)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class absDifference_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('absDifference_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sum_args:
  """
  Attributes:
   - bufferName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferName', None, None, ), # 1
  )

  def __init__(self, bufferName=None,):
    self.bufferName = bufferName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sum_args')
    if self.bufferName is not None:
      oprot.writeFieldBegin('bufferName', TType.STRING, 1)
      oprot.writeString(self.bufferName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sum_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.DOUBLE:
          self.success = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sum_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.DOUBLE, 0)
      oprot.writeDouble(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumSquaredDifference_args:
  """
  Attributes:
   - bufferA
   - bufferB
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferA', None, None, ), # 1
    (2, TType.STRING, 'bufferB', None, None, ), # 2
  )

  def __init__(self, bufferA=None, bufferB=None,):
    self.bufferA = bufferA
    self.bufferB = bufferB

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferA = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.bufferB = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumSquaredDifference_args')
    if self.bufferA is not None:
      oprot.writeFieldBegin('bufferA', TType.STRING, 1)
      oprot.writeString(self.bufferA)
      oprot.writeFieldEnd()
    if self.bufferB is not None:
      oprot.writeFieldBegin('bufferB', TType.STRING, 2)
      oprot.writeString(self.bufferB)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumSquaredDifference_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.DOUBLE:
          self.success = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumSquaredDifference_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.DOUBLE, 0)
      oprot.writeDouble(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class subtract_args:
  """
  Attributes:
   - bufferA
   - bufferB
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferA', None, None, ), # 1
    (2, TType.STRING, 'bufferB', None, None, ), # 2
  )

  def __init__(self, bufferA=None, bufferB=None,):
    self.bufferA = bufferA
    self.bufferB = bufferB

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferA = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.bufferB = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('subtract_args')
    if self.bufferA is not None:
      oprot.writeFieldBegin('bufferA', TType.STRING, 1)
      oprot.writeString(self.bufferA)
      oprot.writeFieldEnd()
    if self.bufferB is not None:
      oprot.writeFieldBegin('bufferB', TType.STRING, 2)
      oprot.writeString(self.bufferB)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class subtract_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('subtract_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_args:
  """
  Attributes:
   - bufferA
   - bufferB
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferA', None, None, ), # 1
    (2, TType.STRING, 'bufferB', None, None, ), # 2
  )

  def __init__(self, bufferA=None, bufferB=None,):
    self.bufferA = bufferA
    self.bufferB = bufferB

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferA = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.bufferB = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_args')
    if self.bufferA is not None:
      oprot.writeFieldBegin('bufferA', TType.STRING, 1)
      oprot.writeString(self.bufferA)
      oprot.writeFieldEnd()
    if self.bufferB is not None:
      oprot.writeFieldBegin('bufferB', TType.STRING, 2)
      oprot.writeString(self.bufferB)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setValues_args:
  """
  Attributes:
   - bufferName: Buffer name
   - value: New value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferName', None, None, ), # 1
    (2, TType.I32, 'value', None, None, ), # 2
  )

  def __init__(self, bufferName=None, value=None,):
    self.bufferName = bufferName
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setValues_args')
    if self.bufferName is not None:
      oprot.writeFieldBegin('bufferName', TType.STRING, 1)
      oprot.writeString(self.bufferName)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 2)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setValues_result:
  """
  Attributes:
   - err
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, err=None,):
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setValues_result')
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class threshold_args:
  """
  Attributes:
   - bufferName: Buffer name
   - thresholdValue: Value to test against
   - maxValue: Value to set if condition is met
   - invert: Invert response
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferName', None, None, ), # 1
    (2, TType.I32, 'thresholdValue', None, None, ), # 2
    (3, TType.I32, 'maxValue', None, None, ), # 3
    (4, TType.BOOL, 'invert', None, None, ), # 4
  )

  def __init__(self, bufferName=None, thresholdValue=None, maxValue=None, invert=None,):
    self.bufferName = bufferName
    self.thresholdValue = thresholdValue
    self.maxValue = maxValue
    self.invert = invert

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.thresholdValue = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxValue = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.invert = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('threshold_args')
    if self.bufferName is not None:
      oprot.writeFieldBegin('bufferName', TType.STRING, 1)
      oprot.writeString(self.bufferName)
      oprot.writeFieldEnd()
    if self.thresholdValue is not None:
      oprot.writeFieldBegin('thresholdValue', TType.I32, 2)
      oprot.writeI32(self.thresholdValue)
      oprot.writeFieldEnd()
    if self.maxValue is not None:
      oprot.writeFieldBegin('maxValue', TType.I32, 3)
      oprot.writeI32(self.maxValue)
      oprot.writeFieldEnd()
    if self.invert is not None:
      oprot.writeFieldBegin('invert', TType.BOOL, 4)
      oprot.writeBool(self.invert)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class threshold_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('threshold_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class normalize_args:
  """
  Attributes:
   - bufferName: Buffer name
   - minValue: Normalize from
   - maxValue: Normalize to
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferName', None, None, ), # 1
    (2, TType.I32, 'minValue', None, None, ), # 2
    (3, TType.I32, 'maxValue', None, None, ), # 3
  )

  def __init__(self, bufferName=None, minValue=None, maxValue=None,):
    self.bufferName = bufferName
    self.minValue = minValue
    self.maxValue = maxValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.minValue = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxValue = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('normalize_args')
    if self.bufferName is not None:
      oprot.writeFieldBegin('bufferName', TType.STRING, 1)
      oprot.writeString(self.bufferName)
      oprot.writeFieldEnd()
    if self.minValue is not None:
      oprot.writeFieldBegin('minValue', TType.I32, 2)
      oprot.writeI32(self.minValue)
      oprot.writeFieldEnd()
    if self.maxValue is not None:
      oprot.writeFieldBegin('maxValue', TType.I32, 3)
      oprot.writeI32(self.maxValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class normalize_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('normalize_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class quantize_args:
  """
  Attributes:
   - bufferName: Buffer name
   - minValue: Normalize from
   - maxValue: Normalize to
   - levels: How many discrete levels to quantize to
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferName', None, None, ), # 1
    (2, TType.I32, 'minValue', None, None, ), # 2
    (3, TType.I32, 'maxValue', None, None, ), # 3
    (4, TType.I32, 'levels', None, None, ), # 4
  )

  def __init__(self, bufferName=None, minValue=None, maxValue=None, levels=None,):
    self.bufferName = bufferName
    self.minValue = minValue
    self.maxValue = maxValue
    self.levels = levels

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.minValue = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxValue = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.levels = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('quantize_args')
    if self.bufferName is not None:
      oprot.writeFieldBegin('bufferName', TType.STRING, 1)
      oprot.writeString(self.bufferName)
      oprot.writeFieldEnd()
    if self.minValue is not None:
      oprot.writeFieldBegin('minValue', TType.I32, 2)
      oprot.writeI32(self.minValue)
      oprot.writeFieldEnd()
    if self.maxValue is not None:
      oprot.writeFieldBegin('maxValue', TType.I32, 3)
      oprot.writeI32(self.maxValue)
      oprot.writeFieldEnd()
    if self.levels is not None:
      oprot.writeFieldBegin('levels', TType.I32, 4)
      oprot.writeI32(self.levels)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class quantize_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('quantize_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resample_args:
  """
  Attributes:
   - bufferName: Buffer name
   - newLength: Number of samples in returned buffer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferName', None, None, ), # 1
    (2, TType.I32, 'newLength', None, None, ), # 2
  )

  def __init__(self, bufferName=None, newLength=None,):
    self.bufferName = bufferName
    self.newLength = newLength

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.newLength = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resample_args')
    if self.bufferName is not None:
      oprot.writeFieldBegin('bufferName', TType.STRING, 1)
      oprot.writeString(self.bufferName)
      oprot.writeFieldEnd()
    if self.newLength is not None:
      oprot.writeFieldBegin('newLength', TType.I32, 2)
      oprot.writeI32(self.newLength)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resample_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resample_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class medianFilter_args:
  """
  Attributes:
   - bufferName: Buffer name
   - fitlerSize: Strength of the filter. Larger number is stronger. Must be >=1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bufferName', None, None, ), # 1
    (2, TType.I32, 'fitlerSize', None, None, ), # 2
  )

  def __init__(self, bufferName=None, fitlerSize=None,):
    self.bufferName = bufferName
    self.fitlerSize = fitlerSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bufferName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.fitlerSize = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('medianFilter_args')
    if self.bufferName is not None:
      oprot.writeFieldBegin('bufferName', TType.STRING, 1)
      oprot.writeString(self.bufferName)
      oprot.writeFieldEnd()
    if self.fitlerSize is not None:
      oprot.writeFieldBegin('fitlerSize', TType.I32, 2)
      oprot.writeI32(self.fitlerSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class medianFilter_result:
  """
  Attributes:
   - success
   - err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (emException, emException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, err=None,):
    self.success = success
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = emException()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('medianFilter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
