#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class emExceptionType:
  CRITICAL = 0
  NONFATAL = 1

  _VALUES_TO_NAMES = {
    0: "CRITICAL",
    1: "NONFATAL",
  }

  _NAMES_TO_VALUES = {
    "CRITICAL": 0,
    "NONFATAL": 1,
  }

class emLogEventType:
  """
  Standard types of waveform that the signal generator can produce
  """
  emNULL = 0
  CONFIG = 1
  emERROR = 2
  MISC = 3
  COMMAND = 4
  RESPONSE = 5
  DONOTLOG = 6
  DISPLAYASMESSAGEBOX = 7

  _VALUES_TO_NAMES = {
    0: "emNULL",
    1: "CONFIG",
    2: "emERROR",
    3: "MISC",
    4: "COMMAND",
    5: "RESPONSE",
    6: "DONOTLOG",
    7: "DISPLAYASMESSAGEBOX",
  }

  _NAMES_TO_VALUES = {
    "emNULL": 0,
    "CONFIG": 1,
    "emERROR": 2,
    "MISC": 3,
    "COMMAND": 4,
    "RESPONSE": 5,
    "DONOTLOG": 6,
    "DISPLAYASMESSAGEBOX": 7,
  }

class emSequenceOperationType:
  """
  The EM controller plays back a set of operations. Think of it as a multitrack audio editing software. Logcally, each PIN has its own queue of operations. Each of these operations has a start and end time, and a set of parameters to define what each pin will be doing during that time. Operations are one of a few basic types:
  """
  emNULL = 0
  ARBITRARY = 1
  RECORD = 2
  WAIT = 3
  PREDEFINED = 4
  CONSTANT = 5
  DIGITAL = 6
  CONSTANT_FROM_REGISTER = 7

  _VALUES_TO_NAMES = {
    0: "emNULL",
    1: "ARBITRARY",
    2: "RECORD",
    3: "WAIT",
    4: "PREDEFINED",
    5: "CONSTANT",
    6: "DIGITAL",
    7: "CONSTANT_FROM_REGISTER",
  }

  _NAMES_TO_VALUES = {
    "emNULL": 0,
    "ARBITRARY": 1,
    "RECORD": 2,
    "WAIT": 3,
    "PREDEFINED": 4,
    "CONSTANT": 5,
    "DIGITAL": 6,
    "CONSTANT_FROM_REGISTER": 7,
  }

class emWaveFormType:
  """
  Standard types of waveform that the signal generator can produce
  """
  emNULL = 0
  ARBITRARY = 1
  PWM = 2
  SAW = 3
  SINE = 4

  _VALUES_TO_NAMES = {
    0: "emNULL",
    1: "ARBITRARY",
    2: "PWM",
    3: "SAW",
    4: "SINE",
  }

  _NAMES_TO_VALUES = {
    "emNULL": 0,
    "ARBITRARY": 1,
    "PWM": 2,
    "SAW": 3,
    "SINE": 4,
  }


class emLogServerSettings:
  """
  Structure to encapsulate log setting

  Attributes:
   - logServer: URL for log server
   - experimentName: Name of experiment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'logServer', None, None, ), # 1
    (2, TType.STRING, 'experimentName', None, None, ), # 2
  )

  def __init__(self, logServer=None, experimentName=None,):
    self.logServer = logServer
    self.experimentName = experimentName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.logServer = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.experimentName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('emLogServerSettings')
    if self.logServer is not None:
      oprot.writeFieldBegin('logServer', TType.STRING, 1)
      oprot.writeString(self.logServer)
      oprot.writeFieldEnd()
    if self.experimentName is not None:
      oprot.writeFieldBegin('experimentName', TType.STRING, 2)
      oprot.writeString(self.experimentName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class emException(TException):
  """
  The device directly controlling the EM should make sure sensible things are happening, and if not throw an exception.  All methods should return problems via exceptions.  Exceptions should contain as much information as possible.  Exceptions can be fatal or non fatal. On a fatal exception, the controlling program should probably abandon what it is doing and reset.

  Attributes:
   - errorCode: Error codes, to be defined in documentation
   - Reason: Why the error was thrown
   - Source: Where (e.g. module, line number) the error came from
   - exceptionType: What type of error this is
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'errorCode', None, None, ), # 1
    (2, TType.STRING, 'Reason', None, None, ), # 2
    (3, TType.STRING, 'Source', None, None, ), # 3
    (4, TType.I32, 'exceptionType', None, None, ), # 4
  )

  def __init__(self, errorCode=None, Reason=None, Source=None, exceptionType=None,):
    self.errorCode = errorCode
    self.Reason = Reason
    self.Source = Source
    self.exceptionType = exceptionType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.errorCode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.Reason = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.Source = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.exceptionType = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('emException')
    if self.errorCode is not None:
      oprot.writeFieldBegin('errorCode', TType.I32, 1)
      oprot.writeI32(self.errorCode)
      oprot.writeFieldEnd()
    if self.Reason is not None:
      oprot.writeFieldBegin('Reason', TType.STRING, 2)
      oprot.writeString(self.Reason)
      oprot.writeFieldEnd()
    if self.Source is not None:
      oprot.writeFieldBegin('Source', TType.STRING, 3)
      oprot.writeString(self.Source)
      oprot.writeFieldEnd()
    if self.exceptionType is not None:
      oprot.writeFieldBegin('exceptionType', TType.I32, 4)
      oprot.writeI32(self.exceptionType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class emWaveForm:
  """
  Structure for an arbitrary wave form.

  Attributes:
   - Samples: Buffer holding the values
   - Rate: Playback rate
   - SampleCount: Length of the buffer
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'Samples', (TType.I32,None), None, ), # 1
    (2, TType.I32, 'Rate', None, None, ), # 2
    (3, TType.I32, 'SampleCount', None, None, ), # 3
  )

  def __init__(self, Samples=None, Rate=None, SampleCount=None,):
    self.Samples = Samples
    self.Rate = Rate
    self.SampleCount = SampleCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.Samples = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI32();
            self.Samples.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.Rate = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.SampleCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('emWaveForm')
    if self.Samples is not None:
      oprot.writeFieldBegin('Samples', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.Samples))
      for iter6 in self.Samples:
        oprot.writeI32(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.Rate is not None:
      oprot.writeFieldBegin('Rate', TType.I32, 2)
      oprot.writeI32(self.Rate)
      oprot.writeFieldEnd()
    if self.SampleCount is not None:
      oprot.writeFieldBegin('SampleCount', TType.I32, 3)
      oprot.writeI32(self.SampleCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class emSequenceItem:
  """
  Definition of an operation to be performed. Not all parameters may be used. It will depend on the operationType. If something can't be performed by the EM, exceptions should be thrown when adding to the buffers. Timings are defined by FPGA ticks, which will need to be converted to Hz.

  Attributes:
   - operationType: What the action is
   - pin: Where the action is applied to, as a list of connections to the material
   - startTime: Ticks it should start at
   - endTime: Ticks it should end at
   - frequency: Definition of signal, if appropriate
   - phase
   - cycleTime
   - amplitude
   - waveFormType: Predefined wave form, eg. square, sawtooth, sine
   - waveForm: If playing back an arbitrary signal, buffer is attached here
   - waitForTrigger: If >=0 wait for a trigger on certain pin before running
   - ValueSourceRegister: if  CONSTANT_FROM_REGISTER, then use this value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'operationType', None, None, ), # 1
    (2, TType.LIST, 'pin', (TType.I32,None), None, ), # 2
    (3, TType.I64, 'startTime', None, None, ), # 3
    (4, TType.I64, 'endTime', None, None, ), # 4
    (5, TType.I32, 'frequency', None, 0, ), # 5
    (6, TType.I32, 'phase', None, 0, ), # 6
    (7, TType.I32, 'cycleTime', None, 0, ), # 7
    (8, TType.I32, 'amplitude', None, 0, ), # 8
    (9, TType.I32, 'waveFormType', None, None, ), # 9
    (10, TType.STRUCT, 'waveForm', (emWaveForm, emWaveForm.thrift_spec), None, ), # 10
    (11, TType.I32, 'waitForTrigger', None, -1, ), # 11
    (12, TType.I32, 'ValueSourceRegister', None, -1, ), # 12
  )

  def __init__(self, operationType=None, pin=None, startTime=None, endTime=None, frequency=thrift_spec[5][4], phase=thrift_spec[6][4], cycleTime=thrift_spec[7][4], amplitude=thrift_spec[8][4], waveFormType=None, waveForm=None, waitForTrigger=thrift_spec[11][4], ValueSourceRegister=thrift_spec[12][4],):
    self.operationType = operationType
    self.pin = pin
    self.startTime = startTime
    self.endTime = endTime
    self.frequency = frequency
    self.phase = phase
    self.cycleTime = cycleTime
    self.amplitude = amplitude
    self.waveFormType = waveFormType
    self.waveForm = waveForm
    self.waitForTrigger = waitForTrigger
    self.ValueSourceRegister = ValueSourceRegister

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.operationType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.pin = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readI32();
            self.pin.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.startTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.endTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.frequency = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.phase = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.cycleTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.amplitude = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.waveFormType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.waveForm = emWaveForm()
          self.waveForm.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.waitForTrigger = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.ValueSourceRegister = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('emSequenceItem')
    if self.operationType is not None:
      oprot.writeFieldBegin('operationType', TType.I32, 1)
      oprot.writeI32(self.operationType)
      oprot.writeFieldEnd()
    if self.pin is not None:
      oprot.writeFieldBegin('pin', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.pin))
      for iter13 in self.pin:
        oprot.writeI32(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.startTime is not None:
      oprot.writeFieldBegin('startTime', TType.I64, 3)
      oprot.writeI64(self.startTime)
      oprot.writeFieldEnd()
    if self.endTime is not None:
      oprot.writeFieldBegin('endTime', TType.I64, 4)
      oprot.writeI64(self.endTime)
      oprot.writeFieldEnd()
    if self.frequency is not None:
      oprot.writeFieldBegin('frequency', TType.I32, 5)
      oprot.writeI32(self.frequency)
      oprot.writeFieldEnd()
    if self.phase is not None:
      oprot.writeFieldBegin('phase', TType.I32, 6)
      oprot.writeI32(self.phase)
      oprot.writeFieldEnd()
    if self.cycleTime is not None:
      oprot.writeFieldBegin('cycleTime', TType.I32, 7)
      oprot.writeI32(self.cycleTime)
      oprot.writeFieldEnd()
    if self.amplitude is not None:
      oprot.writeFieldBegin('amplitude', TType.I32, 8)
      oprot.writeI32(self.amplitude)
      oprot.writeFieldEnd()
    if self.waveFormType is not None:
      oprot.writeFieldBegin('waveFormType', TType.I32, 9)
      oprot.writeI32(self.waveFormType)
      oprot.writeFieldEnd()
    if self.waveForm is not None:
      oprot.writeFieldBegin('waveForm', TType.STRUCT, 10)
      self.waveForm.write(oprot)
      oprot.writeFieldEnd()
    if self.waitForTrigger is not None:
      oprot.writeFieldBegin('waitForTrigger', TType.I32, 11)
      oprot.writeI32(self.waitForTrigger)
      oprot.writeFieldEnd()
    if self.ValueSourceRegister is not None:
      oprot.writeFieldBegin('ValueSourceRegister', TType.I32, 12)
      oprot.writeI32(self.ValueSourceRegister)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class emDebugInfo:
  """
  Debug struct

  Attributes:
   - stateBlob
   - stateBlobLength
   - values
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'stateBlob', None, None, ), # 1
    (2, TType.I32, 'stateBlobLength', None, None, ), # 2
    (3, TType.MAP, 'values', (TType.STRING,None,TType.STRING,None), None, ), # 3
  )

  def __init__(self, stateBlob=None, stateBlobLength=None, values=None,):
    self.stateBlob = stateBlob
    self.stateBlobLength = stateBlobLength
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.stateBlob = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.stateBlobLength = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.values = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin()
          for _i18 in xrange(_size14):
            _key19 = iprot.readString();
            _val20 = iprot.readString();
            self.values[_key19] = _val20
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('emDebugInfo')
    if self.stateBlob is not None:
      oprot.writeFieldBegin('stateBlob', TType.STRING, 1)
      oprot.writeString(self.stateBlob)
      oprot.writeFieldEnd()
    if self.stateBlobLength is not None:
      oprot.writeFieldBegin('stateBlobLength', TType.I32, 2)
      oprot.writeI32(self.stateBlobLength)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.values))
      for kiter21,viter22 in self.values.items():
        oprot.writeString(kiter21)
        oprot.writeString(viter22)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
